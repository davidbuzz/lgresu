// Copyright 2018 Jens Kaemmerer. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"encoding/json"
	"github.com/brutella/can"
	rs "github.com/jens18/lgresu/lgresustatus"
	log "github.com/sirupsen/logrus"
	"io/ioutil"
	"net"
	"net/http"
	"net/http/httptest"
	"os/exec"
	"syscall"
	"testing"
	"time"
)

type MockDatarecorder struct {
	Cnt int
}

func (d *MockDatarecorder) WriteToDatafile(currentTime time.Time, record string) {
	d.Cnt++
}

type MockCanbus struct {
	PublishCnt    int
	DisconnectCnt int
}

func (c *MockCanbus) Publish(can.Frame) error {
	c.PublishCnt++
	return nil
}

func (c *MockCanbus) Disconnect() error {
	c.DisconnectCnt++
	return nil
}

// canbusTestMessages contains test messages generated by the LG Resu 10 LV battery BMS
var canbusTestMessages = []struct {
	Identifier uint32
	Data       [8]byte
}{
	// volt/amp/temp (LG Resu -> Inverter):
	{
		Identifier: rs.BMS_VOLT_AMP_TEMP,
		Data:       [8]byte{0x4b, 0x15, 0xed, 0xff, 0xba, 0x00, 0x00, 0x00},
	},
	// ? (LG Resu -> Inverter): unknown message type (appears to be a constant)
	{
		Identifier: rs.BMS_SERIAL_NUM,
		Data:       [8]byte{0x04, 0xc0, 0x00, 0x1f, 0x03, 0x00, 0x00, 0x00},
	},
	// configuration parameters (LG Resu -> Inverter):
	{
		Identifier: rs.BMS_LIMITS,
		Data:       [8]byte{0x41, 0x02, 0x96, 0x03, 0x96, 0x03, 0x00, 0x00},
	},
	// state of charge/health (LG Resu -> Inverter):
	{
		Identifier: rs.BMS_SOC_SOH,
		Data:       [8]byte{0x4d, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00},
	},
	// warnings/alarms (LG Resu -> Inverter):
	{
		Identifier: rs.BMS_WARN_ALARM,
		Data:       [8]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	},
}

func sendCanbusMessages(ifName string) {
	iface, err := net.InterfaceByName(ifName)

	if err != nil {
		log.Fatalf("sendCanbusMessages(): Could not find network interface %s (%v) \n", ifName, err)
	}

	// bind to socket
	conn, err := can.NewReadWriteCloserForInterface(iface)

	if err != nil {
		log.Fatalf("sendCanbusMessages(): Could not bind to socket %v \n", err)
	}

	bus := can.NewBus(conn)

	f := can.Frame{}

	for {
		// send all LG Resu 10 test messages in one block
		for _, tm := range canbusTestMessages {

			f.ID = tm.Identifier
			f.Length = uint8(len(tm.Data))
			f.Data = tm.Data

			bus.Publish(f)

			log.Debugf("%#4x # % -24X \n", tm.Identifier, tm.Data)
		}

		// wait for 1 second
		<-time.After(time.Second * 1)
	}
}

func init() {
	// only log warning severity or above.
	log.SetLevel(log.WarnLevel)
}

// https://blog.questionable.services/article/testing-http-handlers-go/

// TestIndex tests if the HTTP request returns a JSON object.
func TestIndex(t *testing.T) {

	// prepare lgResuStatus message
	lgResu := &rs.LgResuStatus{Soc: 78, Soh: 99, Voltage: 54.55, Current: -1, Temp: 26.1}

	// channel to signal request from Index
	httpSigChan := make(chan bool)
	// channel to send data to Index
	recordHttpChan := make(chan rs.LgResuStatus)

	// simulate BrokerRecord, issue exactly one lgResu object
	go func() {
		select {
		case <-httpSigChan: // wait for 'HTTP request pending' signal
			recordHttpChan <- *lgResu // send lrResu object
		}
	}()

	req, err := http.NewRequest("GET", "/", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(Index(httpSigChan, recordHttpChan))

	// Call ServeHTTP method directly and pass in Request and ResponseRecorder.
	handler.ServeHTTP(rr, req)

	// Check the status code is what we expect.
	if status := rr.Code; status != http.StatusOK {
		t.Errorf("Index() handler returned wrong status code %v, expect %v \n",
			status, http.StatusOK)
	}

	// extract JSON message
	b := []byte(rr.Body.String())

	// re-constructed lgResuStatus message
	var status rs.LgResuStatus
	err = json.Unmarshal(b, &status)
	if err != nil {
		t.Error(err)
	}

	// test Soc received against Soc send
	if status.Soc != lgResu.Soc {
		t.Errorf("Index handler() returned Soc value %v, expect Soc value %v \n",
			status.Soc, lgResu.Soc)
	}
}

// TestWriteRecord tests if a request for an lgResu object is made after 1 second.
func TestWriteRecord(t *testing.T) {

	// prepare lgResuStatus message
	lgResu := &rs.LgResuStatus{Soc: 78, Soh: 99, Voltage: 54.55, Current: -1, Temp: 26.1}

	// channel to signal request from WriteRecord to BrokerRecord
	writeSigChan := make(chan bool)

	// channel to receive data from BrokerRecord to WriteRecord
	recordWriteChan := make(chan rs.LgResuStatus)

	// simulate BrokerRecord
	go func() {
		for {
			select {
			case <-writeSigChan: // wait for 'HTTP request pending' signal
				recordWriteChan <- *lgResu // send lrResu object
			}
		}
	}()

	dataRecorder := &MockDatarecorder{}

	// write record to datafile
	go writeRecord(writeSigChan, recordWriteChan, dataRecorder, 1)

	time.Sleep(3 * time.Second)

	if dataRecorder.Cnt != 2 {
		t.Errorf("writeRecorder() requested %d lgResu objects, expect %d requests \n",
			dataRecorder.Cnt, 2)
	}
}

// TestSendKeepAlive tests the periodical generation of keep alive messages.
func TestSendKeepAlive(t *testing.T) {

	// channel to terminate sendKeepAlive goroutine
	termSigChan := make(chan bool)

	_ = termSigChan

	canbus := &MockCanbus{}

	// send keep-alive message to LG Resu 10
	go sendKeepAlive(termSigChan, canbus, 1)

	time.Sleep(3 * time.Second)

	if canbus.PublishCnt != 2 {
		t.Errorf("sendKeepAlive() generated %d keep alive messages, expect %d messages \n",
			canbus.PublishCnt, 2)
	}

	// stop the sendKeepAlive goroutine, there should be no additional keep alive messages
	termSigChan <- true

	time.Sleep(3 * time.Second)

	if canbus.PublishCnt != 2 {
		t.Errorf("sendKeepAlive() generated %d keep alive messages, expect %d messages \n",
			canbus.PublishCnt, 2)
	}
}

// TestDecodeCanFrame tests decoding of a CanBus frame in a closure.
func TestDecodeCanFrame(t *testing.T) {

	recordEmitChan := make(chan rs.LgResuStatus)

	decoder := decodeCanFrame(recordEmitChan)

	frm := can.Frame{
		ID:     rs.BMS_SOC_SOH,
		Length: 8,
		Flags:  0,
		Res0:   0,
		Res1:   0,
		Data:   [8]byte{0x4d, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00},
	}

	// simulate the canbus goroutine, executing decoder() as a normal function will cause a deadlock
	go decoder(frm)

	lgResu := rs.LgResuStatus{}
	lgResu = <-recordEmitChan

	if lgResu.Soc != 77 {
		t.Errorf("decodeCanFrame() produce Soc = %d, expect Soc = 77 \n",
			lgResu.Soc)
	}
}

//
func TestBrokerRecord(t *testing.T) {

	// channel to signal request from WriteRecord to BrokerRecord
	writeSigChan := make(chan bool)

	// channel to signal request from Index to BrokerRecord
	httpSigChan := make(chan bool)

	// channel to receive data from BrokerRecord to WriteRecord
	recordWriteChan := make(chan rs.LgResuStatus)

	// channel to receive data from BrokerRecord to Index
	recordHttpChan := make(chan rs.LgResuStatus)

	recordEmitChan := make(chan rs.LgResuStatus)

	go brokerRecord(recordEmitChan, writeSigChan, recordWriteChan, httpSigChan, recordHttpChan)

	// prepare lgResuStatus message
	lgResu := &rs.LgResuStatus{Soc: 78, Soh: 99, Voltage: 54.55, Current: -1, Temp: 26.1}

	recordEmitChan <- *lgResu

	// send write request signal
	writeSigChan <- true
	// receive lgResu
	lgResuWrite := <-recordWriteChan

	// send http request signal
	httpSigChan <- true
	// receive lgResu
	lgResuHttp := <-recordHttpChan

	if lgResuWrite.Soc != 78 || lgResuHttp.Soc != 78 {
		t.Errorf("brokerRecord() produce Soc = %d, expect Soc = 78 \n",
			lgResuWrite.Soc)
	}
}

// TestIntegration tests if the HTTP request returns a JSON object.
func TestIntegration(t *testing.T) {

	// start lgresu_mon server, combine stdout and stderr
	cmd := exec.Command("sh", "-c",
		"go run lgresu_mon.go lgresu_actors.go -if vcan0 -d debug -p 9090 -dr data -r 7 > lg_resu_mon.log 2>&1")
	// https://medium.com/@felixge/killing-a-child-process-and-all-of-its-children-in-go-54079af94773
	cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}

	// start in background
	err := cmd.Start()
	if err != nil {
		log.Fatal(err)
	}

	// generate CANBus messages
	go sendCanbusMessages("vcan0")

	// time to startup lg_resu_mon server
	time.Sleep(3 * time.Second)

	// HTTP request
	resp, err := http.Get("http://localhost:9090")
	if err != nil {
		t.Log(err) // handle error
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)

	log.Debugf("body = %s \n", body)

	// re-constructed lgResuStatus message
	var status rs.LgResuStatus
	err = json.Unmarshal(body, &status)
	if err != nil {
		t.Error(err)
	}

	// test Soc received against Soc send
	if status.Soc != 77 {
		t.Errorf("Index handler() returned Soc value %v, expect Soc value %v \n",
			status.Soc, 77)
	}

	// stop process when test is complete
	syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL)
}
